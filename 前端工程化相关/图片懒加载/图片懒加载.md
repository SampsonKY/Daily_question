# 图片懒加载
图片懒加载在一些图片密集型的网站中运用比较多，通过图片懒加载可以让一些不可视的图片不去加载，避免一次性加载过多的图片导致请求阻塞（浏览器一般对同一域名下的并发请求的连接数有限制），这样就可以提高网站的加载速度，提高用户体验。 

## 实现步骤
**第一步**：首先我们需要让我们html中需要懒加载的img标签的src设置缩略图或者不设置src，然后自定义一个属性，值为真正的图片或者原图的地址（比如下面的data-src），并且定义一个类名，表示该图片是需要懒加载的（比如下面例子的lazy-image），这有两个作用： 

- 为以后获取需要懒加载图片的img元素 
- 可以给这个类名设置背景图片，作为图片未加载前的过度图片，比如显示为loading的图片。 
```html
<img data-src="https://tb1.bdstatic.com/tb/cms/liveshow/ent_slid2.jpg" class="lazy-image"/> 
```
```css
// css部分 
.lazy-image { 
    background: url('../img/loading.gif') no-repeat center; 
} 
```
**第二步**：页面加载完后，我们需要获取所有需要懒加载的图片的元素集合，判断是否在可视区域，如果是在可视区域的话，设置元素的src属性值为真正图片的地址。
```js
inViewShow() {     
    let imageElements = Array.prototype.slice.call(document.querySelectorAll('.lazy-image'))    
    let len = imageElements.length     
    for(let i = 0; i < len; i++) {         
        let imageElement = imageElements[i]        
        const rect = imageElement.getBoundingClientRect() // 出现在视野的时候加载图片         
        if(rect.top < document.documentElement.clientHeight) {             
            imageElement.src = imageElement.dataset.src // 移除掉已经显示的             
            imageElements.splice(i, 1)             
            len--             
            i--         
        }     
    } 
}
```
这里判断是否出现在可视区域内，是通过获取元素的`getBoundingClientRect`属性的`top`值和页面的`clientHeight`进行对比，如果`top`值小于`clientHeight`，则说明元素出现在可视区域了。`BoundingClientRect`是获取某个元素相对于视窗的位置集合，见下图，注意`bottom`和`right`和我们平时的`right`和`bottom`不一样。 
![view](https://user-gold-cdn.xitu.io/2018/10/9/16658bac81b76814?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**第三步**：当用户滚动窗口的时候，遍历所有需要懒加载的元素，通过每个元素的`BoundingClientRect`属性来判断元素是否出现在可视区域内，判断方法同第二步一样。
```js
document.addEventListener('scroll', inViewShow)
```
这里我们可以优化下，可以通过函数节流优化滚动事件的处理函数。

## 利用高级特性Intersection Observer来判断元素是否可见
上面我们利用元素的`BoundingClientRect`的`top`属性和`body`的`clientHeight`来判断元素是否可见，这种传统方式获取元素是否可见的一个缺点是我们还需要绑定`scroll`事件，`scroll`事件是伴随着大量计算的，会造成资源浪费，虽然我们可以通过节流函数来提高性能，但还是会有性能浪费的问题，而`Intersection Observer`可以不用监听`scroll`事件，做到元素一可见便调用回调，在回调里面我们来判断元素是否可见。
```js
if ("IntersectionObserver" in window) {        
    let lazyImageObserver = new IntersectionObserver((entries, observer) => {          
        entries.forEach((entry, index) => {            
            // 如果元素可见            
            if (entry.intersectionRatio > 0) {              
                let lazyImage = entry.target              
                lazyImage.src = lazyImage.dataset.src              
                lazyImage.classList.remove("lazy-image")              
                lazyImageObserver.unobserve(lazyImage)              
                // this.lazyImages.splice(index, 1)            
            }          
        })        
    })        
    this.lazyImages.forEach(function(lazyImage) {          
        lazyImageObserver.observe(lazyImage);        
    })      
}
```
- Intersection Observer API 会注册一个回调函数，每当被监视的元素进入或者退出另外一个元素时(或者 viewport )，或者两个元素的相交部分大小发生变化时，该回调方法会被触发执行。

- 创建一个 IntersectionObserver对象，并传入相应参数和回调用函数，该回调函数将会在目标(target)元素和根(root)元素的交集大小超过阈值(threshold)规定的大小时候被执行。
  ```js
    let options = {
        root: document.querySelector('#scrollArea'),//默认为浏览器视窗
        rootMargin: '0px',
        threshold: 1.0
    }

    let observer = new IntersectionObserver(callback, options);
  ```
- 阈值为1.0意味着目标元素完全出现在root选项指定的元素中可见时，回调函数将会被执行。
- 为每个观察者配置一个目标
    ```js
    let target = document.querySelector('#listItem');
    observer.observe(target);
    ```

# 图片预加载
资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。预加载简单来说就是**将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源**。

在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。

**原理**：让img 标签先显示其他的图片，当其指向的真实图片缓存完成后，再显示为实际的图片。

## 实现方法
```js
function preLoadImg(url, callback) {
    var img = new Image();
    img.src = url;
    //兼容ie、opera刷新页面时，不触发onload事件
    if (img.complete) { // 如果图片已经存在于浏览器缓存，直接调用回调函数
        callback(img);
        return; // 直接返回，不用再处理onload事件
    }
    img.onload = function() { //图片下载完毕时异步调用callback函数。
        callback(img);
    };
}
window.onload = function() {
    var arr = ["img/11.jpg", "img/12.jpg", "img/13.jpg"],
        imgs = document.getElementsByTagName("img"),
        len = imgs.length;
    preLoadImg(arr[0], function(data) {
        imgs[0].src = data.src;
    });
    preLoadImg(arr[1], function(data) {
        imgs[1].src = data.src;
    });
};
```
首先实例化一个Image对象赋值给img，然后设置img.src为参数url指定的图片地址,接着判断img的complete属性，如果本地有这张图片的缓存，则该值为true，此时我们可以直接操作这张图片，如果本地没有缓存，则该值为false，此时我们需要监听img的onload事件。


## 对比
两者都是提高页面性能有效的办法，**两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力**。