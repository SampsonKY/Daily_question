- 都是用来声明变量的。
- let 声明的变量仅在块级作用域有效。
- 关于for循环，设置循环变量的那一部分是一个父作用域，而循环体内是一个单独的子作用域。（JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。）（每次迭代循环的时都创建一个新变量，并以之前迭代中同名变量的值将其初始化。）
```js
for(let i=0; i<3; i++){
    let i = 'abc'
    console.log(i)
}
```
输出3次"abc"。这表明函数内部的变量 i 与循环变量 i 不在同一作用域，有各自单独的作用域。
- var 声明的变量，会发生**变量提升**现象，即变量可以在声明之前使用，值为 undefined。let 声明的变量只能在声明后使用，否则会报错。
- ES6规定：如果在区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。在语法上，称之为**暂时性死区**。
- typeof一个神奇的地方：
```js
typeof x //"undefined"

typeof y // ReferenceError
let y
```
- let 不允许在相同作用域内，重复声明一个变量。

**为什么需要块级作用域**
- ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。
    - 内层变量可能会覆盖外层变量
    - ```js
        var tmp = "hi";
        function fun(){
            console.log(tmp);
            if(false){
             var tmp = 'hello';   
            }
        }
        f()//'undefined'
        ```
    -  用来计数的循环变量泄露为全局变量
    
    **ES6的块级作用域**
    - let实际上为JavaScript新增了块级作用域。
    - ES6允许块级作用域的任意嵌套。
    - 内层作用域可以定义外层作用域的同名变量。
    
    **const**
    - const声明一个只读的常量，一旦声明，常量的值就不能改变。这就意味着const一旦声明变量，就必须从立即初始化。
    - const的作用域和let相同：只在声明的块级作用域内有效。
    - const声明的常量也不提升，同样存在暂时性死区。
    - const和let一样不可以重复声明。
    - 本质：const保证的是变量指向的那个内存地址保存的数据不得改动。对于基本数据类型，值就保存在变量指向的那个内存地址，因此等同于常量，但引用累性格，保存的只是一个指向实际数据的指针，const只能保证指针是固定的，它指向的数据结构是可变的。
    - 如果想将对象冻结，应该使用Object.freeze方法。
    
    - var和function命令声明的全局变量是顶层对象的属性，let const和class声明的全局变量不是。